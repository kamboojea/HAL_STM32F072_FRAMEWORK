/**
 * @file uart.h
 * @brief Source file for UART driver
 */
#include <string.h>
#include "uart.h"

// Todo: Remove UART interrupts generated by configuration tool from build

/*****************************************************************************
   Defines
*****************************************************************************/

#define MAX_UARTS		5		// current limit on STM32s
#define NOT_ASSIGNED    NULL

/**
 * @brief Enumeration for UART assignment indices
 */
typedef enum {
    UART1_ASSIGNMENT_INDEX, /**< Index for UART1 assignment */
    UART2_ASSIGNMENT_INDEX, /**< Index for UART2 assignment */
    UART3_ASSIGNMENT_INDEX, /**< Index for UART3 assignment */
    UART4_ASSIGNMENT_INDEX, /**< Index for UART4 assignment */
    UART5_ASSIGNMENT_INDEX, /**< Index for UART5 assignment */
} uart_assignment_index_t;


/*****************************************************************************
   Variables
*****************************************************************************/

/**
 * @brief Array of UART driver instances for assignments
 * @details This array stores pointers to instances of UART drivers.
 * The array is initialized to contain NULL pointers for all UARTs.
 * The pointers are updated to point to the relevant UART drivers
 * during runtime when an assignment is made.
 */
static uart_t *(uart_assignment[MAX_UARTS]) = {NOT_ASSIGNED};


/*****************************************************************************
   Function prototypes
*****************************************************************************/
static uart_assignment_index_t usart_handle_to_uart_assignment_index(UART_HandleTypeDef *uart);
static inline bool uart_assigned(UART_HandleTypeDef *uart);
static inline void assign_uart(uart_t *uart);


/*****************************************************************************
   Functions
*****************************************************************************/
/**
 * @brief Initializes the UART driver
 * @param me Pointer to the UART driver instance
 * @param name Name of the device
 * @param uart Pointer to the UART handle
 * @param rx_buffer Pointer to the receive circular buffer
 * @param tx_buffer Pointer to the transmit circular buffer
 * @return True if initialization is successful, false otherwise
 */
bool uart_init(uart_t * const me, UART_HandleTypeDef *huart, const char *name, circular_buf_t * const rx_buffer, circular_buf_t * const tx_buffer)
{
    // check if UART is already assigned
    if (uart_assigned(huart))
        return false;

    me->huart = huart;
    me->name = name;
    me->rx_buffer = rx_buffer;
    me->tx_buffer = tx_buffer;
    assign_uart(me);

    /* Enable the UART Parity Error and UART Framing Error Interrupt */
    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
    __HAL_UART_ENABLE_IT(huart, UART_IT_FE);

    /* Enable the UART Error Interrupt: (noise error, overrun error) */
    __HAL_UART_ENABLE_IT(huart, UART_IT_NE);
    __HAL_UART_ENABLE_IT(huart, UART_IT_ORE);

    /* Enable the UART Data Register not empty Interrupt */
    __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);

    return true;
}


/**
 * @brief Receives a byte from the UART
 * @param me Pointer to the UART driver instance
 * @param byte Pointer to the location where received byte will be stored
 * @return True if byte is received successfully, false otherwise
 */
bool uart_rx_byte(uart_t * const me, uint8_t *byte)
{
	return circular_buf_remove(me->rx_buffer, byte);
}


/**
 * @brief Transmits a byte over the UART
 * @param me Pointer to the UART driver instance
 * @param byte Byte to be transmitted
 * @return True if byte is transmitted successfully, false otherwise
 */
bool uart_tx_byte(uart_t * const me, uint8_t byte)
{
	if (!circular_buf_insert(me->tx_buffer, byte))
		return false;

	// Enable UART transmission interrupt
	__HAL_UART_ENABLE_IT(me->huart, UART_IT_TXE);
	return true;
}


/**
 * @brief Transmits a buffer of data over the UART
 * @param me Pointer to the UART driver instance
 * @param buffer Pointer to the data buffer to be transmitted
 * @param size Number of bytes to be transmitted
 * @return True if buffer is transmitted successfully, false otherwise
 */
bool uart_tx_buffer(uart_t * const me, uint8_t *buffer, uint16_t size)
{
	while (size--)
	{
		if (!uart_tx_byte(me, *buffer++))
			return false;
	}
	return true;
}


/**
 * @brief Transmits a null-terminated string over the UART
 * @param me Pointer to the UART driver instance
 * @param str Pointer to the null-terminated string to be transmitted
 * @return True if string is transmitted successfully, false otherwise
 */
bool uart_tx_string(uart_t * const me, char *str)
{
	return uart_tx_buffer(me, (uint8_t*) str, strlen(str) + 1);
}


/**
 * @brief  This function handles UART interrupt request.
 * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
 *                the configuration information for the specified UART module.
 * @details This function is called when a UART interrupt occurs. It reads
 * the received data from the UART's RX buffer and writes data from the UART
 * TX buffer to the UART's data register. If there is no data to transmit,
 * the TX interrupt is disabled.
 */
void uart_isr (UART_HandleTypeDef *huart)
{
    uint32_t isrflags = READ_REG(huart->Instance->ISR);
    uint32_t cr1its = READ_REG(huart->Instance->CR1);
    uint8_t data;

    /* If RXNE flag is set and the RXNE interrupt is enabled */
    if ((isrflags & USART_ISR_RXNE) && (cr1its & USART_CR1_RXNEIE))
    {
        huart->Instance->ICR;                    /* Clear interrupt flags */
        data = huart->Instance->RDR;             /* Read data register */

        if (uart_assigned(huart))
            circular_buf_insert(uart_assignment[usart_handle_to_uart_assignment_index(huart)]->rx_buffer, data);
    }

    /* If interrupt is caused due to Transmit Data Register Empty */
    if ((isrflags & USART_ISR_TXE) && (cr1its & USART_CR1_TXEIE))
    {
        if (!uart_assigned(huart))
        {
            // Nothing to do with us, so disable interrupts
            __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
            return;
        }

        if (!circular_buf_remove(uart_assignment[usart_handle_to_uart_assignment_index(huart)]->tx_buffer, &data))
        {
            // Buffer empty, so disable interrupts
            __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
            return;
        }

        huart->Instance->ICR;                   /* Clear interrupt flags */
        huart->Instance->TDR = data;             /* Write to the transmit data register */
    }
}


/*****************************************************************************
   Private Functions
*****************************************************************************/

/**
 * @brief Converts a UART handle to its corresponding assignment index
 * @param uart Pointer to the UART handle
 * @return The UART assignment index
 */
static uart_assignment_index_t usart_handle_to_uart_assignment_index(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
        return UART1_ASSIGNMENT_INDEX;

    if (huart->Instance == USART2)
        return UART2_ASSIGNMENT_INDEX;

    if (huart->Instance == USART3)
        return UART3_ASSIGNMENT_INDEX;

    return UART3_ASSIGNMENT_INDEX;
}


/**
 * @brief Checks if a UART is assigned to a particular handle
 * @param huart Pointer to the UART handle
 * @return true if the UART is assigned, false otherwise
 */
static inline bool uart_assigned(UART_HandleTypeDef *huart)
{
    return uart_assignment[usart_handle_to_uart_assignment_index(huart)] != NOT_ASSIGNED;
}


/**
 * @brief Assigns a UART to its corresponding handle
 * @param uart Pointer to the UART driver instance
 * @details This function assigns a UART to its corresponding handle
 * in the @c uart_assignment array. The array is used to keep track of
 * which UART driver is assigned to which UART handle.
 */
static inline void assign_uart(uart_t *uart)
{
    uart_assignment[usart_handle_to_uart_assignment_index(uart->huart)] = uart;
}

